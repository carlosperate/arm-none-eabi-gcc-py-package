import shutil
import itertools
from pathlib import Path
from typing import Optional

import typer
from typing_extensions import Annotated
from rich import print

from toolchain_package_builder import package_creator
from toolchain_package_builder.package_creator import PACKAGE_NAME, PACKAGE_PATH, PACKAGE_SRC_PATH


app = typer.Typer()
PROJECT_ROOT = Path(__file__).resolve().parents[1]

@app.command()
def clean():
    """
    Cleans the project from any build artifacts.
    """
    print("[green]Cleaning project[/green]")
    files = [
        PROJECT_ROOT / PACKAGE_NAME / "MANIFEST.in",
        PROJECT_ROOT / PACKAGE_NAME / "pyproject.toml",
    ]
    folders = [
        PROJECT_ROOT / PACKAGE_NAME / "src" / f"{PACKAGE_NAME}.egg-info",
        PROJECT_ROOT / PACKAGE_NAME / "build",
    ]

    print("\nDeleting explicity files and folders...")
    for file in files:
        if file.exists():
            file.unlink()
            print(f"\tDeleted file: {file.relative_to(PROJECT_ROOT)}")
    for folder in folders:
        if folder.exists():
            shutil.rmtree(folder)
            print(f"\tDeleted folder: {folder.relative_to(PROJECT_ROOT)}")

    # All autogenerated "run_*.py" files
    print("\nFinding run_*.py files...")
    for run_file in (PROJECT_ROOT / PACKAGE_NAME / "src" / PACKAGE_NAME).rglob(
        "run_*.py"
    ):
        run_file.unlink()
        print(f"\tDeleted file: {run_file.relative_to(PROJECT_ROOT)}")

    # Find all __pycache__ folders and delete them, excluding directories starting with a dot
    print("\nFinding __pycache__ folders...")
    for folder in PROJECT_ROOT.rglob("__pycache__"):
        if not folder.relative_to(PROJECT_ROOT).parts[0].startswith("."):
            shutil.rmtree(folder)
            print(f"\tDeleted folder: {folder.relative_to(PROJECT_ROOT)}")

    # Find any GCC folders or compressed files and delete them
    print("\nFinding GCC folders and compressed files...")
    gcc_files = itertools.chain(
        PROJECT_ROOT.rglob("gcc-arm-*"),
        PROJECT_ROOT.rglob("arm-gnu-toolchain*"),
    )
    for file in gcc_files:
        if file.relative_to(PROJECT_ROOT).parts[0].startswith("."):
            continue
        if file.is_file() and str(file).endswith((".zip", ".tar.bz2", ".tar.xz")):
            file.unlink()
            print(f"\tDeleted file: {file.relative_to(PROJECT_ROOT)}")
        elif file.is_dir():
            shutil.rmtree(file)
            print(f"\tDeleted folder: {file.relative_to(PROJECT_ROOT)}")

    print("\nCleaning done!")


@app.command()
def build(
    release: Annotated[Optional[str], typer.Option(help="GCC release name")] = None,
    os: Annotated[Optional[str], typer.Option(help="Operating System name")] = None,
    arch: Annotated[Optional[str], typer.Option(help="CPU architecture")] = None,
):
    #clean()

    print("\n[green]Start building Python package[/green]")

    print(f"Package directory: {PACKAGE_PATH.relative_to(Path.cwd())}")
    if not PACKAGE_PATH.is_dir() or not PACKAGE_SRC_PATH.is_dir():
        raise FileNotFoundError(f"Package directory not found: {PACKAGE_SRC_PATH}")

    gcc_release, gcc_release_name, gcc_release_arch = package_creator.get_gcc_release(
        release, os, arch
    )
    print(f"GCC release: {gcc_release_name} ({gcc_release_arch})")

    # Get the GCC release and uncompress it in the package directory
    print("\n[green]Downloading and uncompressing GCC toolchain[/green]")
    #gcc_zip_file = package_creator.download_toolchain(gcc_release["url"])
    #gcc_path = package_creator.uncompress_toolchain(gcc_zip_file, PACKAGE_SRC_PATH)

    # Create the package files with the GCC toolchain folder inside
    print("\n[green]Creating Python package files[/green]")
    #package_creator.create_package_files(PACKAGE_SRC_PATH, gcc_path)

    print("\n[green]Building Python wheel[/green]")
    package_creator.build_python_wheel(PACKAGE_PATH, PROJECT_ROOT / "dist")

    print("\n[green]Package created![/green]")


def main():
    app()


if __name__ == "__main__":
    main()
