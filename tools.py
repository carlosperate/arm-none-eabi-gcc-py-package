#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import shutil
import itertools
from pathlib import Path
from typing import Optional

import typer
from typing_extensions import Annotated
from rich import print, console, panel

from tools_src.simple_repository_generator import generate_simple_repository
from tools_src import package_creator as pc
from tools_src.package_creator import (
    PROJECT_NAME,
    PACKAGE_NAME,
    PACKAGE_ROOT,
    PACKAGE_PATH,
)


app = typer.Typer()
err_console = console.Console(stderr=True)
PROJECT_ROOT = Path(__file__).resolve().parents[0]
PACKAGE_PYPI_ROOT = PROJECT_ROOT / f"{PROJECT_NAME}-pypi"
SIMPLE_REPO_DEFAULT_GH_REPO = "carlosperate/arm-none-eabi-gcc-py-package"
SIMPLE_REPO_DEFAULT_OP_PATH = PROJECT_ROOT / "simple_repository_static"


def error_exit(message: str, exit_code: int = 1):
    err_console.print(panel.Panel.fit(f"[red]{message}[/red]", title="ERROR"))
    raise typer.Exit(code=exit_code)


def package_clean():
    """
    Cleans the project from any build artifacts.
    """
    files = [
        PACKAGE_ROOT / "MANIFEST.in",
        PACKAGE_ROOT / "pyproject.toml",
    ]
    folders = [
        PROJECT_ROOT / ".mypy_cache",
        PACKAGE_ROOT / "build",
        PACKAGE_ROOT / "src" / f"{PACKAGE_NAME}.egg-info",
        SIMPLE_REPO_DEFAULT_OP_PATH,
    ]

    print("\nDeleting explicitly files and folders...")
    for file in files:
        if file.exists():
            file.unlink()
            print(f"\tDeleted file: {file.relative_to(PROJECT_ROOT)}")
    for folder in folders:
        if folder.exists():
            shutil.rmtree(folder)
            print(f"\tDeleted folder: {folder.relative_to(PROJECT_ROOT)}")

    # All autogenerated "run_*.py" files
    print("\nFinding run_*.py files...")
    for run_file in (PACKAGE_PATH).rglob("run_*.py"):
        run_file.unlink()
        print(f"\tDeleted file: {run_file.relative_to(PROJECT_ROOT)}")

    # Find all __pycache__ folders and delete them, excluding directories starting with a dot
    print("\nFinding __pycache__ folders...")
    for folder in PROJECT_ROOT.rglob("__pycache__"):
        if not folder.relative_to(PROJECT_ROOT).parts[0].startswith("."):
            shutil.rmtree(folder)
            print(f"\tDeleted folder: {folder.relative_to(PROJECT_ROOT)}")

    # Find any GCC folders or compressed files and delete them
    print("\nFinding GCC folders and compressed files...")
    gcc_files = itertools.chain(
        PROJECT_ROOT.rglob("gcc-arm-*"),
        PROJECT_ROOT.rglob("arm-gnu-toolchain*"),
        PACKAGE_PATH.rglob("arm_none_eabi_*"),
    )
    for file in gcc_files:
        # Don't delete files or folders in dot directories
        if file.relative_to(PROJECT_ROOT).parts[0].startswith("."):
            continue
        # Delete compressed files
        if file.is_file() and str(file).endswith((".zip", ".tar.bz2", ".tar.xz")):
            file.unlink()
            print(f"\tDeleted file: {file.relative_to(PROJECT_ROOT)}")
        # Delete folders that start with these names
        elif file.is_dir():
            shutil.rmtree(file)
            print(f"\tDeleted folder: {file.relative_to(PROJECT_ROOT)}")

    print("\nCleaning done!")


@app.command()
def clean():
    print("[green]Cleaning package project[/green]")
    package_clean()


@app.command()
def package_creator(
    release: Annotated[str, typer.Argument(help="GCC release name (can be 'latest')")],
    all: bool = typer.Option(
        False, help="Build all versions of the release, ignoring --os and --arch."
    ),
    os: Annotated[
        Optional[str], typer.Option(help="Specify Operating System (mac/win/linux)")
    ] = None,
    arch: Annotated[
        Optional[str],
        typer.Option(help="Specify CPU architecture (x86_64, arm64, aarch64)"),
    ] = None,
):
    """
    Generates and builds the Python package/s with the selected GCC release.

    If os and arch are not set it will build all versions of the release.
    Otherwise, it will build the specified os and arch (both must be set).
    """
    print("\n[green]Start building Python package/s[/green]")

    print(f"Package root directory: {PACKAGE_ROOT.relative_to(Path.cwd())}\n")
    if not PACKAGE_ROOT.is_dir() or not PACKAGE_PATH.is_dir():
        error_exit(
            f"Project/Package directory not found:\n\t{PACKAGE_ROOT}\n\t{PACKAGE_PATH}"
        )

    if not (os and arch) and (os or arch):
        error_exit("Both --os and --arch must be set if one of them is set.")
    if all and (os or arch):
        error_exit("Cannot use --all with --os or --arch.")

    if all:
        os_arch = None
    elif os and arch:
        os_arch = (os, arch)
    else:
        os_arch = (None, None)

    selected_gcc_releases = pc.get_gcc_releases(release, os_arch)
    for gcc_release in selected_gcc_releases:
        # Perform a clean build for each release
        clean()

        release_name = f"{gcc_release.release_name} ({gcc_release.os_arch}"
        print(f"\n[green]Building GCC release: {release_name})[/green]")

        # Get the GCC release and uncompress it in the package directory
        print("\n[green]Downloading and uncompressing GCC toolchain[/green]")
        gcc_zip_file = pc.download_toolchain(gcc_release.files["url"])
        gcc_path = pc.uncompress_toolchain(gcc_zip_file, PACKAGE_PATH)

        # Create the package files with the GCC toolchain folder inside
        print("\n[green]Creating Python package files[/green]")
        package_version = pc.generate_package_version(gcc_release.release_name)
        pc.create_package_files(PACKAGE_ROOT, PACKAGE_PATH, gcc_path, package_version)

        print("\n[green]Building Python wheel[/green]")
        dist_folder = PROJECT_ROOT / "dist"
        dist_folder.mkdir(exist_ok=True)
        wheel_path = pc.build_wheel(
            PACKAGE_ROOT, dist_folder, gcc_release.files["wheel_plat"]
        )

        print("\n[green]Producing metadata files[/green]")
        metadata_file = wheel_path.with_suffix(f"{wheel_path.suffix}.metadata")
        metadata_file.write_text(pc.get_package_metadata(PACKAGE_PATH))
        pc.create_sha256_hash(metadata_file)
        pc.create_sha256_hash(wheel_path)
        print("Done.")

    print("\n[green]Building source distribution for PyPI[/green]")
    # Only need to build the source distribution once, as it'a single tar file
    # for all the wheels built and it only uses their metadata
    pc.build_pypi_source_dist(PACKAGE_PYPI_ROOT, dist_folder, wheel_path)

    print(f"\n[green]Package {release_name}) created![/green]\n")


@app.command()
def package_get_version(gcc_release_name: str):
    """
    Get the package version string for the specified GCC release.
    """
    # Check the release name exists (all releases have win version), but ignore result
    _ = pc.get_gcc_releases(gcc_release_name, ("win", "x86_64"))
    package_version = pc.generate_package_version(gcc_release_name)
    print(f"{package_version}")


@app.command()
def package_versions():
    """
    Get the GCC version strings for all available releases.
    """
    releases = pc.get_gcc_release_names()
    print(f'["{releases[0]}"', end="")
    for release in releases:
        print(f', "{release}"', end="")
    print("]")


@app.command()
def repo_generate(
    repo: Annotated[Optional[str], typer.Option()] = SIMPLE_REPO_DEFAULT_GH_REPO,
    output: Annotated[Optional[Path], typer.Option()] = SIMPLE_REPO_DEFAULT_OP_PATH,
    overwrite: bool = True,
):
    """
    Generate a simple repository from wheels found in a GH repository Releases.

    :param repo: The GitHub repository to generate the repository from.
    :param overwrite: Overwrite the output folder if it exists.
    """
    print(f"Generating simple repository from GH Releases in: {repo}")
    if overwrite:
        if output.exists():
            if not output.is_dir():
                raise NotADirectoryError(f"Output path '{output}' is not a directory.")
            shutil.rmtree(output)
    elif output.exists():
        raise FileExistsError(
            f"Output path {output} already exists, delete it or use --overwrite."
        )
    print(f"Output path: {output.relative_to(Path.cwd())}")
    generate_simple_repository(repo, output)


def main():
    app()


if __name__ == "__main__":
    main()
